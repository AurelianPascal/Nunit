using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Producer;
using Azure.Identity;

public class EventHubPublisher : IAsyncDisposable
{
    private readonly EventHubProducerClient _producerClient;

    public EventHubPublisher(string fullyQualifiedNamespace, string eventHubName, TokenCredential credential, EventHubProducerClientOptions options)
    {
        _producerClient = new EventHubProducerClient(fullyQualifiedNamespace, eventHubName, credential, options);
    }

    public async Task SendMessagesAsync(List<EventData> events)
    {
        using EventDataBatch eventBatch = await _producerClient.CreateBatchAsync();

        foreach (var eventData in events)
        {
            if (!eventBatch.TryAdd(eventData))
            {
                // If the batch is full, send it and create a new one
                await _producerClient.SendAsync(eventBatch);
                eventBatch.Dispose();
                eventBatch = await _producerClient.CreateBatchAsync();
                eventBatch.TryAdd(eventData);
            }
        }

        if (eventBatch.Count > 0)
        {
            await _producerClient.SendAsync(eventBatch);
        }
    }

    public async ValueTask DisposeAsync()
    {
        await _producerClient.DisposeAsync();
    }
}


####
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using Azure.Identity;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Producer;

class Program
{
    private const string FullyQualifiedNamespace = "<Your Event Hub namespace>.servicebus.windows.net";
    private const string EventHubName = "<Your Event Hub name>";

    static async Task Main(string[] args)
    {
        var events = new List<EventData>();
        for (int i = 0; i < 1000; i++)  // Adjust the number of events as needed
        {
            var eventBody = Encoding.UTF8.GetBytes($"Event {i}");
            events.Add(new EventData(eventBody));
        }

        var credential = new DefaultAzureCredential();
        var options = new EventHubProducerClientOptions
        {
            // Configure additional options as needed
        };

        await using var eventHubPublisher = new EventHubPublisher(FullyQualifiedNamespace, EventHubName, credential, options);
        await eventHubPublisher.SendMessagesAsync(events);

        Console.WriteLine("All events published.");
    }
}

#####

using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using Azure.Identity;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Producer;
using Moq;

namespace EventHubPublisherTests
{
    [TestClass]
    public class EventHubPublisherTests
    {
        private const string FullyQualifiedNamespace = "<Your Event Hub namespace>.servicebus.windows.net";
        private const string EventHubName = "<Your Event Hub name>";

        [TestMethod]
        public async Task TestSendMessagesAsync()
        {
            // Arrange
            var credential = new DefaultAzureCredential();
            var options = new EventHubProducerClientOptions
            {
                // Configure additional options as needed
            };

            var mockProducerClient = new Mock<EventHubProducerClient>(FullyQualifiedNamespace, EventHubName, credential, options);

            // Mock CreateBatchAsync and SendAsync methods
            var eventDataBatch = new EventDataBatch(256000, 1, FullyQualifiedNamespace, EventHubName);
            mockProducerClient.Setup(p => p.CreateBatchAsync(default))
                .ReturnsAsync(eventDataBatch);

            mockProducerClient.Setup(p => p.SendAsync(It.IsAny<EventDataBatch>(), default))
                .Returns(Task.CompletedTask);

            var eventHubPublisher = new EventHubPublisher(FullyQualifiedNamespace, EventHubName, credential, options);

            // Act
            var events = new List<EventData>
            {
                new EventData(Encoding.UTF8.GetBytes("Event 1")),
                new EventData(Encoding.UTF8.GetBytes("Event 2")),
                new EventData(Encoding.UTF8.GetBytes("Event 3"))
            };

            await eventHubPublisher.SendMessagesAsync(events);

            // Assert
            mockProducerClient.Verify(p => p.SendAsync(It.IsAny<EventDataBatch>(), default), Times.AtLeastOnce);
        }
    }
}

####


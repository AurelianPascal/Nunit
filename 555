using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Processor;

public class EventProcessor
{
    private readonly ConcurrentDictionary<string, Task> _partitionTasks = new ConcurrentDictionary<string, Task>();

    public async Task Handle(ProcessEventArgs args)
    {
        string partitionId = args.Partition.PartitionId;
        
        // Wait for any existing task for this partition to complete
        if (_partitionTasks.TryGetValue(partitionId, out var existingTask))
        {
            await existingTask;
        }

        // Define the task for processing the current event
        var processingTask = ProcessEventAsync(args);

        // Store the task in the dictionary
        _partitionTasks[partitionId] = processingTask;

        try
        {
            // Await the task to ensure it completes
            await processingTask;
        }
        finally
        {
            // Remove the task from the dictionary once it completes
            _partitionTasks.TryRemove(partitionId, out _);
        }
    }

    private async Task ProcessEventAsync(ProcessEventArgs args)
    {
        // Your event processing logic here
        Console.WriteLine($"Processing event for partition: {args.Partition.PartitionId}");
        
        // Simulate some asynchronous work
        await Task.Delay(1000);
    }
}


using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Processor;

public class EventProcessor
{
    private readonly ConcurrentDictionary<string, int> _partitionTaskCounters = new ConcurrentDictionary<string, int>();

    public async Task Handle(ProcessEventArgs args)
    {
        string partitionId = args.Partition.PartitionId;

        // Increment the counter for the partition
        var taskCounter = _partitionTaskCounters.AddOrUpdate(partitionId, 1, (key, oldValue) => oldValue + 1);

        // Log the current counter value
        Console.WriteLine($"Partition {partitionId} task count: {taskCounter}");

        // Check if there are multiple tasks running for the same partition
        if (taskCounter > 1)
        {
            Console.WriteLine($"Warning: Multiple tasks running for partition {partitionId}");
        }

        // Define the task for processing the current event
        var processingTask = ProcessEventAsync(args);

        try
        {
            // Await the task to ensure it completes
            await processingTask;
        }
        finally
        {
            // Decrement the counter for the partition
            _partitionTaskCounters.AddOrUpdate(partitionId, 0, (key, oldValue) => oldValue - 1);

            // Log the updated counter value
            var updatedTaskCounter = _partitionTaskCounters[partitionId];
            Console.WriteLine($"Partition {partitionId} task count after completion: {updatedTaskCounter}");
        }
    }

    private async Task ProcessEventAsync(ProcessEventArgs args)
    {
        // Your event processing logic here
        Console.WriteLine($"Processing event for partition: {args.Partition.PartitionId}");

        // Simulate some asynchronous work
        await Task.Delay(1000);
    }
}
###

using System;
using System.Collections.Concurrent;
using System.Data.SqlClient;
using System.Threading.Tasks;

public class Book
{
    public string Title { get; set; }
    public string Author { get; set; }
    // Other properties...
}

public class BookService
{
    private static int _openConnectionCount = 0;
    private static readonly object _lock = new object();

    public async Task Save(Book b)
    {
        SqlConnection connection = new SqlConnection("YourConnectionStringHere");
        
        try
        {
            IncrementConnectionCount();

            await connection.OpenAsync();
            Console.WriteLine($"Opened connection. Current open connection count: {_openConnectionCount}");

            // Your save logic here, e.g., using SqlCommand to insert the book details into the database
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred: {ex.Message}");
            throw;
        }
        finally
        {
            if (connection.State == System.Data.ConnectionState.Open)
            {
                await connection.CloseAsync();
                Console.WriteLine("Closed connection.");
            }

            DecrementConnectionCount();
            Console.WriteLine($"Current open connection count after closing: {_openConnectionCount}");
        }
    }

    private void IncrementConnectionCount()
    {
        lock (_lock)
        {
            _openConnectionCount++;
        }
    }

    private void DecrementConnectionCount()
    {
        lock (_lock)
        {
            _openConnectionCount--;
        }
    }
}




